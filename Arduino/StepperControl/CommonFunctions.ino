#include <Wire.h>
#include "CommonValues.h"

String LastErrorCodes::gblErrorMessage = "";

//////////////////////////////////////////////////////////////
// "Software Reset" function
void (*softwareReset)(void)=0;
//////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
PinType getPinType(uint8_t pin) {
//////////////////////////////////////////////////////////////
uint8_t port = digitalPinToPort(pin);

if ( port == NOT_A_PIN ) 
  return PT_UNKNOWN;

    // this is uno specific!
    switch ( pin ) {
      case A0: 
      case A1: 
      case A2:
      case A3:
      case A4: 
      case A5: return PT_ANALOG;
    }
    
    return PT_DIGITAL;
}
//////////////////////////////////////////////////////////////
uint8_t getPinMode(uint8_t pin) {
//////////////////////////////////////////////////////////////
  uint8_t bit  = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);

  if ( port == NOT_A_PIN ) 
    return UNKNOWN_PIN;

  // Is there a bit we can check?
  if ( bit == 0 ) 
    return UNKNOWN_PIN;

  // Is there only a single bit set?
  if ( bit & (bit - 1) ) 
    return UNKNOWN_PIN;

  volatile uint8_t *reg, *out;
  reg = portModeRegister(port);
  out = portOutputRegister(port);

  if      (*reg & bit)  return OUTPUT;
  else if (*out & bit)  return INPUT_PULLUP;
  else                  return INPUT;

  return UNKNOWN_PIN;
}
//////////////////////////////////////////////////////////////
void printDigitalPin(const unsigned char Pin, const int Mode) {
//////////////////////////////////////////////////////////////
  int Type = (int)'D'; 
  Serial.print(Pin);  Serial.print(TEXT_SEPARATOR); 
  Serial.print(Type); Serial.print(TEXT_SEPARATOR);
  Serial.print(Mode); Serial.print(TEXT_SEPARATOR);
  Serial.print(digitalRead(Pin));
  Serial.print(TEXT_CLOSE); 
}
//////////////////////////////////////////////////////////////    
void printAnalogPin(const unsigned char Pin, const int Mode) {
//////////////////////////////////////////////////////////////
  int Type = (int)'A'; 
  Serial.print(Pin);  Serial.print(TEXT_SEPARATOR); 
  Serial.print(Type); Serial.print(TEXT_SEPARATOR); 
  Serial.print(Mode); Serial.print(TEXT_SEPARATOR); 
  Serial.print(analogRead(Pin)); 
  Serial.print(TEXT_CLOSE); 
}
//////////////////////////////////////////////////////////////
void sleepMicroseconds(unsigned long usec) {
//////////////////////////////////////////////////////////////
  long milli = usec / 1000;
  long micro = usec % 1000;

  if ( milli )
    delay(milli);
    
  delayMicroseconds(micro);
}
//////////////////////////////////////////////////////////////
bool readI2CSlave(I2CData& data) {
//////////////////////////////////////////////////////////////
  Wire.requestFrom(I2C_DEVICE_ID, I2C_BYTE_COUNT);

  if ( Wire.available() <= 0 )
    return false;

  unsigned int counter = 0;
  while ( Wire.available()) {
    switch ( counter ) {
      case I2C_BYTE_LIMIT_STATE:     data.limitState    = Wire.read();  break;
      case I2C_BYTE_SUPPORT_STATE:   data.supportState  = Wire.read();  break;
      default:  return false;
    }
    counter++;
  }

  return true;
}
//////////////////////////////////////////////////////////////
bool sendDataToI2CSlave(const byte data[], unsigned int len) {
//////////////////////////////////////////////////////////////
  if ( len == 0 )
    return false;

  Wire.beginTransmission(I2C_DEVICE_ID);
  int bytes = Wire.write(data, len);            
  byte ret = Wire.endTransmission();  

  /* ret = 
    0: success
    1: data too long to fit in transmit buffer
    2: received NACK on transmit of address
    3: received NACK on transmit of data
    4: other error 
  */
  
  return ( ret == 0 && bytes == (int)len );
}

//////////////////////////////////////////////////////////////
bool dblCompare(double a, double b) {
//////////////////////////////////////////////////////////////
  return (abs(a - b) < epsilon);
}
/////////////////////////////////////////////////////////////////////////////////////
bool dblCompareNull(double a) {
/////////////////////////////////////////////////////////////////////////////////////
   return dblCompare(a, 0.0);
}
/////////////////////////////////////////////////////////////////////////////////////
bool isDoubleValue(const unsigned char pid) {
/////////////////////////////////////////////////////////////////////////////////////
  return  pid >= PID_DOUBLE_RANG_START; 
}
/////////////////////////////////////////////////////////////////////////////////////
bool convertLongToDouble(const long val, double& ret) {
/////////////////////////////////////////////////////////////////////////////////////
  if ( val == MIN_LONG || val == MAX_LONG ) {
    ret = 0.0;
    return false;
  }
  
  ret = ((double)val)/DBL_FACT; 
  return true;
}
/////////////////////////////////////////////////////////////////////////////////////
void writeByteValue(unsigned char b) {
/////////////////////////////////////////////////////////////////////////////////////
    Serial.write(b);
}
/////////////////////////////////////////////////////////////////////////////////////
void writeByteValue(unsigned char pid, unsigned char b) {
/////////////////////////////////////////////////////////////////////////////////////  
  Serial.write(RET_SOH);
  Serial.write(pid);
  writeByteValue(b);
}
/////////////////////////////////////////////////////////////////////////////////////
void writeByteValues(unsigned char pid, unsigned char b[], unsigned short size) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
  Serial.write(pid);
  
  for ( unsigned short i=0; i<size; i++ ) {
    writeByteValue(b[i]);
  }
}
/////////////////////////////////////////////////////////////////////////////////////
void writeGetterValue(unsigned char pid, int32_t val1) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
  Serial.write(PID_GETTER);
  Serial.write(pid);
  writeByteValue(1);
  writeLongValue(val1);
}
/////////////////////////////////////////////////////////////////////////////////////
void writeGetterValues(unsigned char pid, int32_t val1, int32_t val2) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
  Serial.write(PID_GETTER);
  Serial.write(pid);
  writeByteValue(2);
  writeLongValue(val1);
  writeLongValue(val2);
}
/////////////////////////////////////////////////////////////////////////////////////
void writeGetterValues(unsigned char pid, int32_t val1, int32_t val2, int32_t val3) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
  Serial.write(PID_GETTER);
  Serial.write(pid);
  writeByteValue(3);
  writeLongValue(val1);
  writeLongValue(val2);
  writeLongValue(val3);
}
/////////////////////////////////////////////////////////////////////////////////////
void writeUnsignedIntValue(uint16_t val) {
/////////////////////////////////////////////////////////////////////////////////////
  unsigned char buf[sizeof(uint16_t)];
  memcpy(buf, &val, sizeof(uint16_t));
  Serial.write(buf, sizeof(buf));
}
/////////////////////////////////////////////////////////////////////////////////////
void writeDoubleValue(double val) {
/////////////////////////////////////////////////////////////////////////////////////
  unsigned char buf[sizeof(double)];
  memcpy(buf, &val, sizeof(double));
  Serial.write(buf, sizeof(buf));
}
/////////////////////////////////////////////////////////////////////////////////////
void writeLongValue(long val) {
/////////////////////////////////////////////////////////////////////////////////////
  unsigned char buf[sizeof(long)];
  memcpy(buf, &val, sizeof(long));
  Serial.write(buf, sizeof(buf));
}
/////////////////////////////////////////////////////////////////////////////////////
void writeLongValue(unsigned char pid, long val) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
  Serial.write(pid);
  writeLongValue(val);
}
/////////////////////////////////////////////////////////////////////////////////////
void writeLongValues(unsigned char pid, long val1, long val2) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
  Serial.write(pid);
  writeLongValue(val1);
  writeLongValue(val2);
}
/////////////////////////////////////////////////////////////////////////////////////
void writeLongValues(unsigned char pid, long val1, long val2, long val3) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
  Serial.write(pid);
  writeLongValue(val1);
  writeLongValue(val2);
  writeLongValue(val3);
}
/////////////////////////////////////////////////////////////////////////////////////
void writeLongValues(unsigned char pid, long val1, long val2, long val3, long val4) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
  Serial.write(pid);
  writeLongValue(val1);
  writeLongValue(val2);
  writeLongValue(val3);
  writeLongValue(val4);
}
/////////////////////////////////////////////////////////////////////////////////////
void sendHeartbeat() {
/////////////////////////////////////////////////////////////////////////////////////
  unsigned char byteCount = sizeof(int32_t);
  Serial.write(RET_SOH);
  Serial.write(PID_HEARTBEAT);
  Serial.write(byteCount);
  writeLongValue(millis() % MAX_LONG);
}
/////////////////////////////////////////////////////////////////////////////////////
void sendHeartbeat(unsigned char limitState, unsigned char supportState) {
/////////////////////////////////////////////////////////////////////////////////////
  unsigned char byteCount = 2 * sizeof(int32_t);

  Serial.write(RET_SOH);
  Serial.write(PID_HEARTBEAT);
  Serial.write(byteCount);
  writeLongValue(millis() % MAX_LONG);
  
  for (unsigned int i=0; i<I2C_BYTE_COUNT; i++) {
    switch ( i ) {
      case I2C_BYTE_LIMIT_STATE:    writeByteValue(limitState);   break;
      case I2C_BYTE_SUPPORT_STATE:  writeByteValue(supportState); break;
    }
  }
  
  writeByteValue(255); // reserved
  writeByteValue(255); // reserved
}
/////////////////////////////////////////////////////////////////////////////////////
void pushMessage(const char type, const unsigned char mid, const char* msg) {
/////////////////////////////////////////////////////////////////////////////////////
  Serial.write(RET_SOH);
    Serial.write(PID_MSG);
    switch ( type ) {
      case MT_WARNING:  Serial.write(MT_WARNING); break;
      case MT_ERROR:    Serial.write(MT_ERROR);   break;
      default:          Serial.write(MT_INFO);    break; 
    }

    if ( mid != E_NO_ERROR ) {
      Serial.write(MT_MID_FLAG);
      Serial.write(mid);
    }

    if ( msg != NULL )
      Serial.print(msg);
    
  Serial.write(MBYTE_CLOSE);
  Serial.flush();
}
/////////////////////////////////////////////////////////////////////////////////////
void pushInfoMessage(const unsigned char mid, const char* msg) {
/////////////////////////////////////////////////////////////////////////////////////
  pushMessage(MT_INFO, mid, msg);
}
/////////////////////////////////////////////////////////////////////////////////////
void pushWarningMessage(const unsigned char mid, const char* msg) {
/////////////////////////////////////////////////////////////////////////////////////
  pushMessage(MT_WARNING, mid, msg);
}
/////////////////////////////////////////////////////////////////////////////////////
void pushErrorMessage(const unsigned char mid, const char* msg) {
/////////////////////////////////////////////////////////////////////////////////////
  pushMessage(MT_ERROR, mid, msg);
}
/////////////////////////////////////////////////////////////////////////////////////
void pushInfoMessage(const char* msg) {
/////////////////////////////////////////////////////////////////////////////////////
  pushMessage(MT_INFO, E_NO_ERROR, msg);
}
/////////////////////////////////////////////////////////////////////////////////////
void pushWarningMessage(const char* msg) {
/////////////////////////////////////////////////////////////////////////////////////
  pushMessage(MT_WARNING, E_NO_ERROR, msg);
}
/////////////////////////////////////////////////////////////////////////////////////
void pushErrorMessage(const char* msg) {
/////////////////////////////////////////////////////////////////////////////////////
  pushMessage(MT_ERROR, E_NO_ERROR, msg);
}
/////////////////////////////////////////////////////////////////////////////////////
bool peakSerial(unsigned char& c) {
/////////////////////////////////////////////////////////////////////////////////////
  c = CMD_INVALID;
  
  if ( Serial.available() == 0 )
    return false;
  
  c = Serial.peek();
  return true;
}
/////////////////////////////////////////////////////////////////////////////////////
bool checkSerialForPauseCommands(bool currentPauseState) {
/////////////////////////////////////////////////////////////////////////////////////
    bool ret = currentPauseState;
    
    if ( Serial.available() > 0 ) {
      
      switch ( Serial.peek() ) {
        case 'p': ret = PAUSE_INACTIVE; 
                  // remove the cmd for serial
                  Serial.read(); 
                  break;
                  
        case 'P': ret = PAUSE_ACTIVE;
                  // remove the cmd for serial
                  Serial.read();  
                  break;
      }
    }

    return ret;
}





